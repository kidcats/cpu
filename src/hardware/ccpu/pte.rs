


#[derive(Debug,Clone, Copy)]
pub struct pte_123{
    value : u64
}

impl pte_123 {
    
    pub fn new(value : u64)-> Self{
        pte_123 { value: value }
    }

    /*
    子页表是否在内存中
     */
    pub fn present(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001}
    /*
    对于所有的可访问页,只读或者读写访问权限
     */
    pub fn rw(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000010}

    /**
     * 对于所有的可访问页,用户访问权限等级
     */
    pub fn us(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000100}

    /**
     * 子页表的直接写回或者写回缓存策略
     */
    pub fn wt(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00001000}

    /**
     * 能否缓存子页表
     */
    pub fn cd(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00010000}

    /**
     * 引用位
     */
    pub fn a(&self) ->  u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00100000}

    pub fn ps(&self) ->  u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_10000000}
    /**
     * 能否从这个pte可访问的所有页中取出指令
     */
    pub fn xd(&self) ->  u64{self.value & 0b10000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000}
    pub fn base_addr(&self) ->  u64{self.value & 0b00000000_00001111_11111111_11111111_11111111_11111111_11110000_00000000}

}


#[derive(Debug,Clone, Copy)]
pub struct pte_4{
    value : u64
}

impl pte_4 {

    pub fn new(value : u64)-> Self{
        pte_4 { value: value }
    }


    /*
    子页表是否在内存中
     */
    pub fn present(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001}
    /*
    对于所有的可访问页,只读或者读写访问权限
     */
    pub fn rw(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000010}

    /**
     * 对于所有的可访问页,用户访问权限等级
     */
    pub fn us(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000100}

    /**
     * 子页表的直接写回或者写回缓存策略
     */
    pub fn wt(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00001000}

    /**
     * 能否缓存子页表
     */
    pub fn cd(&self) -> u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00010000}

    /**
     * 引用位
     */
    pub fn a(&self) ->  u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00100000}

    /**
     * 修改位
     */
    pub fn d(&self) ->  u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_01000000}

    /**
     * 全局位 在任务切换的时候,不从tlb中驱除出去
     */
    pub fn g(&self) ->  u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000}

    pub fn ps(&self) ->  u64{self.value & 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_10000000}
    /**
     * 能否从这个pte可访问的所有页中取出指令
     */
    pub fn xd(&self) ->  u64{self.value & 0b10000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000}
    pub fn base_addr(&self) ->  u64{self.value & 0b00000000_00001111_11111111_11111111_11111111_11111111_11110000_00000000}
}